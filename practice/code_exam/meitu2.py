#encoding:utf-8
nmr = map(int,raw_input().split() )
n=nmr[0]
m=nmr[1]
r=nmr[2]
all = map(int,raw_input().split() )

q=[0]*100
s=[]
for t in xrange(0,100):
    s.append(q)

for i in xrange(0,n):
    for j in xrange(i,n):
        a=i
        while all[j]-all[a]>r:
            s[i][j]=s[i][j]+all[j]-all[a]-r
            a+=1
count=1
for i in xrange(0,100):
    for j in xrange(0,100):
        count+=s[i][j]
print count
# for(i=0;i<n;i++)
# {
# for(j=i;j<n;j++)
# { s[i][j]=0;
# for(a=i;ti[j]-ti[a]>r;a++)
# {
# s[i][j]=s[i][j]+ti[j]-ti[a]-r;//计算第i个人到第j个人中间的所有的时间，并且记录
# }

# 保安的苦恼
# 时间限制：C/C++语言 1000MS；其他语言 3000MS
# 内存限制：C/C++语言 65536KB；其他语言 589824KB
# 题目描述：
# 小强是公寓某栋宿舍楼保安，他的职责是一到晚上12点以后就将大门锁住，但是每天12点以后出入宿舍的学生很多，而且一旦有学生出入的时候就必须去开门然后再锁上，一直重复这样的工作效率很低，他希望一个晚上开门的总次数尽量达到最少，于是他每次开门让在门口等待的学生出入之后，再在门口多等R分钟，而且在这段时间内到达门口的学生可无需等待即可直接出入，然后才关上门。比如多等的时间R=2，且开门的时刻为t=5，则t=5或之前时刻来的学生可直接出入并且在t=6,7时刻来的学生仍可直接出入；如果R=0表示每次保安一开门所有在门口等待的学生和这个时间到达的学生可以直接出入然后马上关上门。
# 经过了长时间的观察，他推算出了所有学生出入大门的规律，并且他希望在总开门次数不超过M的情况下，使得所有出入的学生的总等待时间最短，毕竟等待还是让学生们感到很不高兴的。
# 现在请你编个程序求出当开门次数不超过M的情况下最短的总等待时间。
# 输入
# 输入数据的第一行包含三个整数N M R (1<=N,M<=100, 0<=R<=1,000,000)， 表示总共要出入的学生有N个，开门总次数不超过M，每次开门的时候保安在门口继续等待的时间为R。
# 接下来一行N个整数ti(0< ti<=1,000,000)，分别表示N个学生的进出时刻。
# 输出
# 输出学生的最少的总等待时间T。
#
# 样例输入
# 5 2 0
# 1 9 3 8 2
# 样例输出
# 4
#
# Hint
# 对于样例，保安小强可以选择在t=3和t=9的时间开门。