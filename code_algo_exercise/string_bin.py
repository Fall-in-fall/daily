# -*- encoding:utf-8 -*-

#最大回文子串
# 3、中心扩展
# 中心扩展就是把给定的字符串的每一个字母当做中心，向两边扩展，这样来找最长的子回文串。算法复杂度为O(N^2)。
# 但是要考虑两种情况：
# 1、像aba，这样长度为奇数。
# 2、想abba，这样长度为偶数。

#翻转单词顺序：先翻转所有的字母，再将每一个词翻转回正常顺序

#翻转字符串;以下标n为中心对调前后字符串，可以套用上面的方法，将翻转的两部分看作两个词。

# 二进制中1的个数
# “>> 右移,高位补符号位” 这里右移一位表示除2“>>> 无符号右移,高位补0”；
#  与>>类似“<< 左移” 左移一位表示乘2，二位就表示4，就是2的n次方
# 一个数减1在和原数做与，就会把这个数所有1中的最右边的1编成0.
def bitCount(n):
    c=0
    while n >0:
        n = (n-1)&n
        c+=1
    return c

#不使用加减乘除实现加法
# 对于二进制形式的相加，可分两步进行操作：
# 1）先不考虑进位，则0101+1001=1100，从中可以看出，不考虑进位求和即对两个加数进行按位异或操作。
# 2）只考虑进位(两个都为1才进位，刚好对应与操作，与操作位置与实际进位应该加1的位置差一位，左移即可)，对a和b进行与操作，然后左移一位，结果为：0001
# 将考虑进位和不考虑进位的值相加，结果为a和b相加的结果。
# 采用递归思想，重复进行上述两步操作，直至无进位，可实现不使用加减乘除进行加法操作。
def oriAdd(a,b):
    if a == 0: return b
    if b == 0: return a
    return oriAdd(a^b,(a&b<<1) )

# 两个二进制数异或结果 是 这两个二进制数差的绝对值，即表达为如下：a^b = |a-b| （按位相减取绝对值，再按位累加）

# 数组中只出现一次的数(其他都出现了一次)-p211：一个数对同一个数进行两次异或操作，原数保持不变。
    # 依次对数组中的数进行异或，得到的最后结果是只出现一次的数之间的异或结果m，如果只有一个这样的数则直接返回，
    # 如果有x个，则这x个数不可能同一位上都为1，即可以用m的二进位来进行区分。类似于错误编码的一对多分类。
    # m的某一位是否为1，可以用来分开x的一个数与其他数，并且那些相同的数在该位上肯定相同，所以按照该为划分肯定能把成对出现的数划分到一个组
    # 利用这种方法，可以将只出现一次的数分到各个组，然后在组内再进行一遍异或操作从而提取出这个数