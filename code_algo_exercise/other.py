# -*- encoding:utf-8 -*-
#1到n个数中 x(1-9)出现的个数：出现的个数等于如下
# 比如2345中2出现2的数有2,20-29,200-300,2000-2345,个位一个，十位有10+1个，百位有100+11个，依次类推。最后一位有2346+（100+11）个

# 最大公约数：
    # 以大数除以小数，如果能整除，那么小数就是所求的最大公约数．否则再用小数除以余数；
    # 再用这新除法的余数去除刚才的余数．依此类推，直到一个除法能够整除，即余数为0
    # 这时作为除数的数就是所求的最大公约数．
# 最小公倍数： 最小公倍数=两整数的乘积÷最大公约数

# n个骰子的点数-43：n个骰子m个面，每个面对应1-m个数。求掷n个骰子的可能出现的所有和值的概率。以单个骰子六面1-6为例
# 加入第n个骰子后，和为 s 的出现的次数等于n-1个骰子时 s-1...s-6出现的次数之和。也就是n个骰子依赖n-1个骰子的情况。
# 为了使下标看起来清晰，也算入0个骰子的情况，以及和为0的情况，对应下标0
# 其实这里可以更简化只用一维数组存储即可。使用二维数组更直观。http://blog.csdn.net/k346k346/article/details/50988681
def probDiceSum(n,s=-1): #不给定s则返回从1-6n所有值的概率
    if s == -1: s=6*n
    if s<n or s>6*n: # 小于最小和或大于最大和
        return 0
    allCount =  [ [0],[1] * 7 ] #*7是为了包含和为0的情况，方便下标对应和
    allCount[1][0] = 0
    for i_n in xrange(2,n+1): # 2...n个骰子
        cu_s = 6*i_n # 当前骰子数的最大和
        if cu_s> s :cu_s=s # 如果目标和小于最大和，则只求到目标和部分
        # 更新有i_n个骰子时各可能和出现的概率
        allCount.append([0]*(cu_s+1))
        for i_s in xrange(i_n,cu_s+1): # 最小可能和(=当前骰子数) ... 最大可能和
            cuCount = 0
            up = i_s if i_s<7 else 7
            low = i_s - len(allCount[i_n-1])+1
            if low <1: low = 1
            # 注意包含0个骰子的情况后前面实际存储了7个数，而前面的最大和是7-1
            # 当前要得到的和 allCount[i_n-1][i_s-k] 大于i_n-1个骰子的最大和这种情况不存在，不用计算。
            # 比如 i_s=8，i_n = 2时，i_s-1=7，不存在i_n-1=1个骰子的和能够=7，所以使用low-up
            for k in xrange(low,up): # i_n个骰子时i_s的次数就等于 [i_n-1] i_s - 1...i_s - 6 的次数之和
                cuCount += allCount[i_n-1][i_s-k] if i_s-k else 0
            allCount[i_n][i_s] = cuCount
    print allCount
    return float(allCount[n][s])/6**n

#

if __name__ =='__main__':
    print probDiceSum(3,-1)